TITLE: Noah Henderson, CSCI 200 Section A (8 am), Chess Analysis Board

PROBLEM DESCRIPTION: A chess analysis board is a board that is used to test the legality of a move and to show
what moves a piece could potenitally make. These boards are also used to create positions to study. This Projct
aims to make an analysis board that allows for the creation of these positions.

DOCUMENTATION: The way this program works is first it will ask you to point it to a file to write to. Once this
has been accomplishes the main loop starts. The main loop will give the use a black chess board to manipulate.
The user will then follow the prompts to move the pieces around the board as they see fit. They are then able
to Show the moves a piece could take or ask the machine if a move is legal. The user can also grab the current
score of the pieces on the board. These features have all been described. Because this is an analysis board
it allows for some things a normal chess game would not. For instance checkmate. This is becuase there are 
certain studies that require a king to be moved into checkmate these positions are called morphisms. In terms
of features added I added the feature that will check the legality of a move. This was not something I planend
to create but it proved to be something that was fun to code and made sense in the context of the analysis board.
This board also comes with a barebones chess api that could be repurposed into other game/ program loops.

1. Compile
2. The program will prompt you for a file to write to
3. The board will display and you will input the coordinates of a piece
4. choose what to do with that piece from the specified options
5. repeat until you quit


If I had more time:
- I would add two modes the analysis board as well as a genuine chess game
    - This would be somewhat easy to implement with the methods I have already
- I would implement some graphics. As it stands the terminal was the best way for me to do what i wanted in the time we had

LIST DATA STRUCTURE: I chose to use a static 2d array for my list data structure. This structure simply
made sense for a chess board as the number of squares does not change. This means that the board is static
with only the pieces moving. This means that the memory makeup for the array is the same so it makes the
most sense to use.

TESTS:
- Test case 1: inputting a file that does not exist
    - I implemented a failsafe so that if the file does not exit then it will be created
- Test case 2: Choosing an option that is not listed i.e choosing 6
    - if the user inputs a number when choosing an action that is not specified then it will tell the user
    and then it will prompt them again
- Test case 3: Choosing a point/Piece that is not within the range of the board i.e choosing row or column to be 8
    - If this occurs the user will be told that this is out of bounds and then they will be prompted again
- Test Case 4: The user chooses to test a move that is out of bounds i.e they check a move at -1 2
    - If this occurs the user will be made aware and then the program will promt them to re enter the command
- Test Case 5: The user promts for a list of moves on a blank
    - The program will tell the user that this is a blank and then move on and re prompt
- Test Case 6: The user calls for a legal move but the king is in check
    - If the king is in check the user will be notified. The move can still be made as it is an analysis
    board but the legal checkin functionality chekks this for us.

REFLECTION: This project served as a good way for me to hone my programming skills in c++ and in general. I took
a lot of time to learn new techniques that we did not learn in class like using auto and the for each loop. I also
learned various ways to instatiate an variable or object and learned more about the standard library. I was also
able to learn more techniques of how to pass around objects and variables for programs to manipulate. I think that
this project turned out ok but I had to make sacrifices due to the time constraint. I also think that OOP has some
major limitaions when it comes to code structure and maintainability even when using best practices that I would
like to find some remedies to in the future. If I had to do another project I would try to look up more design
patterns or best practices because the hard part about the coding was mainly writing something that was easy to
read,maintain, and change. I would also like to have had more time to come up with a concept as the concept I chose
was kind of rushed so my feature list expanded before I had finished which made the project harder to structure.
Overall I found the project to be helpful as it allowed me to get a better feel for C++ and the software development
lifecycele in general. It alos showed me some of the limitations of what we have been learning which is important.